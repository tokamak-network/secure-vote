// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title IVerifier
 * @notice Interface for Groth16 verifier contracts
 * @dev The actual verifier is generated by snarkjs from the circuit
 */
interface IVerifier {
    /**
     * @notice Verify a Groth16 proof with fixed-size public inputs
     * @param _pA Proof component A (G1 point)
     * @param _pB Proof component B (G2 point)
     * @param _pC Proof component C (G1 point)
     * @param _pubSignals Public signals (14 elements for SingleMessageProcessor)
     * @return True if proof is valid
     */
    function verifyProof(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256[13] calldata _pubSignals
    ) external view returns (bool);
}

/**
 * @title Groth16Verifier
 * @notice Placeholder verifier for development and testing
 * @dev In production, replace with snarkjs-generated verifier
 *
 * To generate the real verifier:
 * 1. Compile circuit: ./scripts/compile-circuit.sh
 * 2. The script generates src/GeneratedVerifier.sol
 * 3. Deploy GeneratedVerifier and use its address
 */
contract Groth16Verifier is IVerifier {
    // ============ Constants ============

    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;

    // ============ Events ============

    event ProofVerified(bool success);

    // ============ Errors ============

    error InvalidProof();
    error InvalidInput();

    // ============ Verification ============

    /**
     * @notice Verify a Groth16 proof (placeholder implementation)
     * @dev In development mode, accepts any non-zero proof
     *      In production, this should be replaced with actual pairing checks
     */
    function verifyProof(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256[13] calldata _pubSignals
    ) external view override returns (bool) {
        // Validate public inputs are in field
        for (uint256 i = 0; i < 13; i++) {
            if (_pubSignals[i] >= SNARK_SCALAR_FIELD) {
                revert InvalidInput();
            }
        }

        // Validate proof points are non-zero (basic sanity check)
        if (_pA[0] == 0 && _pA[1] == 0) {
            revert InvalidProof();
        }
        if (_pC[0] == 0 && _pC[1] == 0) {
            revert InvalidProof();
        }

        // NOTE: This is a placeholder that accepts any valid-looking proof
        // In production, implement actual pairing check:
        // e(A, B) = e(alfa, beta) * e(IC, gamma) * e(C, delta)

        return true;
    }

    /**
     * @notice Verify proof with dynamic public inputs (convenience wrapper)
     */
    function verifyProofDynamic(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256[] calldata _pubSignals
    ) external view returns (bool) {
        // Convert dynamic array to fixed array
        require(_pubSignals.length == 13, "Invalid public signals length");

        uint256[13] memory signals;
        for (uint256 i = 0; i < 13; i++) {
            signals[i] = _pubSignals[i];
        }

        // Validate public inputs are in field
        for (uint256 i = 0; i < 13; i++) {
            if (signals[i] >= SNARK_SCALAR_FIELD) {
                revert InvalidInput();
            }
        }

        // Validate proof points
        if (_pA[0] == 0 && _pA[1] == 0) {
            revert InvalidProof();
        }
        if (_pC[0] == 0 && _pC[1] == 0) {
            revert InvalidProof();
        }

        return true;
    }
}

/**
 * @title VerifierWrapper
 * @notice Wrapper that can switch between placeholder and real verifier
 * @dev Use this in MACIVoting and BisectionGame for upgradability
 */
contract VerifierWrapper {
    // ============ State ============

    IVerifier public verifier;
    address public owner;
    bool public devMode;

    // ============ Events ============

    event VerifierUpdated(address indexed oldVerifier, address indexed newVerifier);
    event DevModeChanged(bool devMode);

    // ============ Errors ============

    error NotOwner();
    error ZeroAddress();

    // ============ Modifiers ============

    modifier onlyOwner() {
        if (msg.sender != owner) revert NotOwner();
        _;
    }

    // ============ Constructor ============

    constructor(address _verifier) {
        owner = msg.sender;
        verifier = IVerifier(_verifier);
        devMode = true; // Start in dev mode
    }

    // ============ Admin Functions ============

    /**
     * @notice Update the verifier contract
     * @param _newVerifier Address of the new verifier
     */
    function setVerifier(address _newVerifier) external onlyOwner {
        if (_newVerifier == address(0)) revert ZeroAddress();
        address oldVerifier = address(verifier);
        verifier = IVerifier(_newVerifier);
        emit VerifierUpdated(oldVerifier, _newVerifier);
    }

    /**
     * @notice Toggle development mode
     * @param _devMode True to enable dev mode (placeholder verification)
     */
    function setDevMode(bool _devMode) external onlyOwner {
        devMode = _devMode;
        emit DevModeChanged(_devMode);
    }

    /**
     * @notice Transfer ownership
     */
    function transferOwnership(address newOwner) external onlyOwner {
        if (newOwner == address(0)) revert ZeroAddress();
        owner = newOwner;
    }

    // ============ Verification ============

    /**
     * @notice Verify a proof
     */
    function verifyProof(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256[13] calldata _pubSignals
    ) external view returns (bool) {
        if (devMode) {
            // In dev mode, accept any non-zero proof
            return _pA[0] != 0 || _pA[1] != 0;
        }

        return verifier.verifyProof(_pA, _pB, _pC, _pubSignals);
    }
}
