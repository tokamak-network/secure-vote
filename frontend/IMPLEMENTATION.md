# Implementation Summary: Secure Vote Web UI

## Overview

A Next.js web interface that enables single-user testing of the threshold cryptography voting system. The user controls only their own wallet (MetaMask), while all other roles are automated via backend scripts.

## Architecture

### Three-Layer System

1. **Frontend (Browser)**
   - User interface built with Next.js + React + Tailwind CSS
   - Wallet connection via RainbowKit + wagmi
   - Vote encryption in browser using offchain library
   - MetaMask for transaction signing

2. **Backend (API Routes)**
   - Demo setup automation (`/api/setup-demo`)
   - Decryption and tally automation (`/api/decrypt-tally`)
   - Public key endpoint (`/api/public-key`)
   - Uses viem with Foundry private keys (server-side only)

3. **Blockchain (Anvil + Solidity)**
   - SecureVoting.sol contract
   - Stores encrypted votes and verified tallies
   - Emits events for vote tracking

## User Flow

```
Setup Demo → Connect Wallet → Vote → Decrypt & Tally → View Results
    ↓            ↓              ↓           ↓              ↓
  Backend     MetaMask      Browser    Backend        On-chain
             (sign tx)    (encrypt)   (decrypt)       (read)
```

### 1. Setup Demo (Automated)
**Endpoint:** `POST /api/setup-demo`

**Actions:**
- Generate threshold key (3-of-5)
- Store shares in `key-shares.json`
- Deposit 10 ETH bond (from account 0)
- Create proposal: "Should we upgrade the protocol?"
- Submit 2 dummy votes:
  - Account 1: Yes
  - Account 2: No

**Output:** Proposal ID 0, ready for user voting

### 2. Connect Wallet (Manual)
- User connects MetaMask to Anvil
- Imports Foundry account 3 as voter
- No transactions yet

### 3. Vote (Manual)
**Page:** `/vote/[id]`

**Actions:**
1. Fetch public key from `/api/public-key`
2. User selects Yes/No
3. Encrypt vote in browser (ElGamal)
4. Submit via MetaMask: `commitVote(proposalId, ciphertext)`
5. Transaction confirms on Anvil

**Cryptography:**
- Uses threshold ElGamal encryption
- Ciphertext = (C1, C2) where:
  - C1 = r*G
  - C2 = m*G + r*PK
- Serialized to hex before submission

### 4. Decrypt & Tally (Automated)
**Endpoint:** `POST /api/decrypt-tally`

**Actions:**
1. Fetch all `VoteCommitted` events from contract
2. Deserialize ciphertexts
3. Load 3-of-5 threshold key shares from storage
4. Create decryption shares for each vote
5. Combine shares to decrypt (threshold decryption)
6. Aggregate: count Yes/No votes
7. Generate Merkle tree of decrypted votes
8. Submit tally to contract: `submitTally(proposalId, yes, no, root)`

**Cryptography:**
- Threshold ElGamal decryption
- Each of 3 committee members creates partial decryption
- Combine using Lagrange interpolation
- Discrete log to recover vote value (0 or 1)

### 5. View Results (Read-only)
**Page:** `/results/[id]`

**Display:**
- Yes/No vote counts with percentages
- Outcome: Passed/Rejected/Tied
- Merkle root for verification
- Submitter address and timestamp

## File Structure

```
frontend/
├── pages/
│   ├── _app.tsx                  # Wagmi + RainbowKit providers
│   ├── _document.tsx             # HTML document structure
│   ├── index.tsx                 # Home page (proposal list + Setup Demo)
│   ├── vote/[id].tsx             # Vote page (Yes/No buttons + MetaMask)
│   ├── committee.tsx             # Committee dashboard (Decrypt & Tally)
│   ├── results/[id].tsx          # Results visualization
│   └── api/
│       ├── setup-demo.ts         # Backend: automated demo setup
│       ├── decrypt-tally.ts      # Backend: threshold decryption
│       └── public-key.ts         # Backend: serve public key
├── components/
│   └── Layout.tsx                # Navigation bar + wallet connect
├── lib/
│   ├── contracts.ts              # Contract ABI + address config
│   ├── crypto-wrapper.ts         # Re-exports from offchain library
│   ├── anvil-helpers.ts          # Foundry account utilities
│   └── wagmi-config.ts           # Wagmi chain configuration
├── styles/
│   └── globals.css               # Tailwind CSS
├── package.json                  # Dependencies
├── tsconfig.json                 # TypeScript config (includes ../offchain)
├── next.config.js                # Next.js + webpack config
├── tailwind.config.js            # Tailwind CSS config
├── .env.local                    # Contract address (gitignored)
├── key-shares.json               # Generated by setup (gitignored)
├── README.md                     # Setup and usage instructions
├── TEST.md                       # Testing guide
└── IMPLEMENTATION.md             # This file
```

## Key Technical Decisions

### 1. In-Memory Key Storage
**Decision:** Store threshold key shares in `key-shares.json` file

**Rationale:**
- Simpler than database for local demo
- Persists across server restarts
- File is gitignored for security

**Production Alternative:**
- Use Redis or encrypted database
- Key management service (AWS KMS, HashiCorp Vault)

### 2. Frontend-Backend Crypto Split
**Frontend (Browser):**
- Encryption only
- Uses offchain library via webpack
- No private keys

**Backend (API routes):**
- Decryption with threshold keys
- Transaction signing with Foundry keys
- Event fetching from contract

**Rationale:**
- Keeps threshold keys server-side only
- User only needs MetaMask for voting
- Backend can automate committee actions

### 3. Webpack TypeScript Transpilation
**Problem:** Next.js doesn't transpile `../offchain/src` by default

**Solution:** Custom webpack config with ts-loader
```javascript
config.module.rules.push({
  test: /\.ts$/,
  include: /offchain/,
  use: [{ loader: 'ts-loader', options: { transpileOnly: true } }],
});
```

**Rationale:**
- Reuses existing offchain library
- No need to publish npm package
- Single source of truth for cryptography

### 4. Event-Based Vote Fetching
**Method:** Use `publicClient.getLogs()` to fetch `VoteCommitted` events

**Rationale:**
- More efficient than iterating proposals.voters array
- Gets all data in one RPC call
- Provides voter address, ciphertext, and timestamp

### 5. No Authentication
**Decision:** Public API routes, no auth required

**Rationale:**
- Local demo on localhost
- Single user testing
- All keys are public Foundry test keys

**Production Alternative:**
- JWT authentication for committee members
- Role-based access control
- Separate committee interface

## Dependencies

### Core
- `next`: 14.0.4 (React framework)
- `react`: 18.2.0
- `viem`: 2.45.1 (Ethereum client)
- `wagmi`: 2.5.0 (React hooks for Ethereum)

### Wallet
- `@rainbow-me/rainbowkit`: 2.0.0 (Wallet connection UI)
- `@tanstack/react-query`: 5.0.0 (Required by wagmi)

### Crypto
- `@noble/curves`: 1.3.0 (BN254 curve)
- `@noble/hashes`: 1.3.3 (Hashing utilities)
- `ethers`: 6.10.0 (Used by offchain library)
- `merkletreejs`: 0.3.11 (Merkle tree for vote verification)

### UI
- `tailwindcss`: 3.4.0 (CSS framework)
- `autoprefixer`: 10.4.16
- `postcss`: 8.4.32

### Dev
- `typescript`: 5.3.3
- `ts-loader`: 9.5.4 (Webpack TypeScript loader)

## Contract Interface

```solidity
// Write functions (used by backend and MetaMask)
function depositBond() payable
function createProposal(string description, uint256 commitDuration, uint256 revealDuration) returns (uint256)
function commitVote(uint256 proposalId, bytes ciphertext)
function submitTally(uint256 proposalId, uint256 yesVotes, uint256 noVotes, bytes32 votesRoot)

// Read functions (used by frontend)
function getProposalCount() view returns (uint256)
function proposals(uint256) view returns (string description, uint256 commitDeadline, uint256 revealDeadline, uint256 totalVotes, bool tallied)
function tallies(uint256) view returns (uint256 yesVotes, uint256 noVotes, bytes32 votesRoot, uint256 submittedAt, address submitter, bool challenged, bool finalized)
function verifyVoteProof(uint256 proposalId, uint256 voteIndex, address voter, uint256 vote, uint256 timestamp, bytes32[] proof) view returns (bool)

// Events (used by backend)
event VoteCommitted(uint256 indexed proposalId, address indexed voter, bytes ciphertext)
```

## API Endpoints

### POST /api/setup-demo
**Purpose:** Automated demo environment setup

**Request:** None (no body)

**Response:**
```json
{
  "success": true,
  "proposalId": 0,
  "publicKey": {
    "x": "123...",
    "y": "456..."
  }
}
```

**Side Effects:**
- Creates `key-shares.json`
- 3 blockchain transactions (bond, proposal, 2 votes)

### POST /api/decrypt-tally
**Purpose:** Decrypt votes and submit tally

**Request:**
```json
{
  "proposalId": 0
}
```

**Response:**
```json
{
  "success": true,
  "result": {
    "yesVotes": 2,
    "noVotes": 1,
    "votesRoot": "0xabc..."
  }
}
```

**Side Effects:**
- Reads `key-shares.json`
- 1 blockchain transaction (submitTally)

### GET /api/public-key
**Purpose:** Serve public key for vote encryption

**Response:**
```json
{
  "publicKey": {
    "x": "123...",
    "y": "456..."
  }
}
```

## Security Considerations

### Test Environment Only
- Uses publicly known Foundry private keys
- No authentication on API routes
- Key shares stored in plain JSON file
- Runs on localhost only

### Production Requirements
1. **Key Management**
   - Encrypted storage for threshold keys
   - Hardware security modules (HSM)
   - Key rotation policies

2. **Authentication**
   - JWT tokens for committee members
   - Role-based access control
   - Audit logs for all actions

3. **Infrastructure**
   - HTTPS only
   - Rate limiting on API routes
   - Distributed key shares (different servers)

4. **Smart Contract**
   - Deploy with real bond amounts
   - Implement challenge mechanism fully
   - Time lock for tally finalization

## Testing

See `TEST.md` for complete testing guide.

**Quick verification:**
```bash
# Start Anvil
anvil

# Deploy contract
forge script script/Deploy.s.sol --rpc-url http://127.0.0.1:8545 --broadcast --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80

# Configure frontend
cd frontend
echo "NEXT_PUBLIC_CONTRACT_ADDRESS=0x5FbDB..." > .env.local
npm run dev

# Open http://localhost:3000
# Click "Setup Demo"
# Connect MetaMask
# Vote
# Decrypt & Tally
# View Results
```

## Future Enhancements

### Phase 1: Verification
- [ ] Merkle proof generation UI
- [ ] On-chain proof verification button
- [ ] Vote receipt download (PDF)

### Phase 2: Multi-Proposal
- [ ] Create proposal form
- [ ] Multiple active proposals
- [ ] Proposal templates

### Phase 3: Committee Features
- [ ] Multi-member committee interface
- [ ] Distributed key generation UI
- [ ] Challenge mechanism UI
- [ ] Slashing visualization

### Phase 4: Production Ready
- [ ] Deploy to Sepolia testnet
- [ ] Authentication system
- [ ] Encrypted key storage
- [ ] Audit logs
- [ ] Admin dashboard

### Phase 5: Advanced Crypto
- [ ] Zero-knowledge vote receipts
- [ ] Anonymous voting (ring signatures)
- [ ] Verifiable shuffles
- [ ] Post-quantum cryptography

## Performance

### Anvil (Local Testnet)
- Setup Demo: ~10s (key gen + 3 txs)
- Vote: ~2s (1 tx)
- Decrypt & Tally: ~5s (fetch events + decrypt + 1 tx)

### Optimizations
- Frontend: Static generation for proposal pages
- Backend: Caching of public key
- Contract: Batch vote submissions
- Crypto: Precomputed tables for discrete log

## Troubleshooting

See `TEST.md` for detailed troubleshooting guide.

**Common issues:**
1. "Contract address not set" → Update `.env.local`
2. "Key shares not found" → Run Setup Demo
3. "Transaction failed" → Check Anvil is running
4. "Insufficient funds" → Restart Anvil
5. Build warnings → React Native deps (ignore)

## Conclusion

The web UI successfully demonstrates the complete secure voting system with minimal user intervention. Users only need to:
1. Click "Setup Demo"
2. Connect MetaMask
3. Vote
4. Click "Decrypt & Tally"
5. View results

All cryptographic complexity (threshold key generation, encryption, decryption, aggregation) is handled automatically by the frontend and backend, providing a smooth user experience while maintaining the security guarantees of the underlying threshold cryptography system.
