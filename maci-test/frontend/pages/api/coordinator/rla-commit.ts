import type { NextApiRequest, NextApiResponse } from 'next';
import { publicClient, walletClient, MACI_RLA_ABI, getAddresses } from '@/lib/server';
import * as path from 'path';
import * as fs from 'fs';

const PROOFS_DIR = path.resolve(process.cwd(), '../proofs-web');
const COMMITMENTS_FILE = path.join(PROOFS_DIR, 'commitments.json');

/**
 * POST /api/coordinator/rla-commit
 * Reads commitments from commitments.json (generated by coordinator-commitments.ts),
 * then calls MaciRLA.commitResult().
 *
 * No proof files required â€” only circuit inputs and extracted commitments.
 */
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const cookie = req.headers.cookie || '';
  const authed = /(?:^|;\s*)coordinator_auth=true(?:;|$)/.test(cookie);
  if (!authed) {
    return res.status(401).json({ success: false, error: 'Unauthorized' });
  }

  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const { maciRla, poll } = getAddresses();
    if (!maciRla || !poll) {
      return res.status(500).json({ success: false, error: 'Contract addresses not configured' });
    }

    if (!fs.existsSync(COMMITMENTS_FILE)) {
      return res.status(400).json({ success: false, error: 'commitments.json not found. Run Extract Commitments first.' });
    }

    const commitmentsData = JSON.parse(fs.readFileSync(COMMITMENTS_FILE, 'utf8'));
    const pmCommitments = commitmentsData.pmCommitments.map((c: string) => BigInt(c));
    const tvCommitments = commitmentsData.tvCommitments.map((c: string) => BigInt(c));
    const yesVotes = BigInt(commitmentsData.yesVotes);
    const noVotes = BigInt(commitmentsData.noVotes);

    const stake = await publicClient.readContract({
      address: maciRla,
      abi: MACI_RLA_ABI,
      functionName: 'coordinatorStake',
    } as any);

    const hash = await walletClient.writeContract({
      address: maciRla,
      abi: MACI_RLA_ABI,
      functionName: 'commitResult',
      args: [poll, pmCommitments, tvCommitments, yesVotes, noVotes],
      value: stake as bigint,
    } as any);

    await publicClient.waitForTransactionReceipt({ hash });

    const nextPollId = await publicClient.readContract({
      address: maciRla,
      abi: MACI_RLA_ABI,
      functionName: 'nextPollId',
    } as any);

    res.status(200).json({
      success: true,
      txHash: hash,
      rlaPollId: Number(nextPollId as bigint) - 1,
      pmBatches: pmCommitments.length - 1,
      tvBatches: tvCommitments.length - 1,
      yesVotes: yesVotes.toString(),
      noVotes: noVotes.toString(),
    });
  } catch (err: any) {
    console.error('rla-commit error:', err);
    res.status(500).json({ success: false, error: err.message });
  }
}
